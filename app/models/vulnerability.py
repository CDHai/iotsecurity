"""
Vulnerability model for managing security vulnerabilities and CVE data
"""

import json
from datetime import datetime
from app import db

class Vulnerability(db.Model):
    """Model representing a security vulnerability."""
    
    __tablename__ = 'vulnerabilities'
    
    # Primary key
    id = db.Column(db.Integer, primary_key=True)
    
    # CVE and external identifiers
    cve_id = db.Column(db.String(20), unique=True, nullable=True, index=True)
    cwe_id = db.Column(db.String(20), nullable=True, index=True)
    external_id = db.Column(db.String(50), nullable=True)  # Other vulnerability databases
    
    # Vulnerability metadata
    title = db.Column(db.String(200), nullable=False)
    description = db.Column(db.Text, nullable=False)
    severity = db.Column(db.Enum('info', 'low', 'medium', 'high', 'critical',
                                name='vuln_severity'), nullable=False, index=True)
    
    # CVSS scoring
    cvss_score = db.Column(db.Float, nullable=True)
    cvss_vector = db.Column(db.String(200), nullable=True)
    cvss_version = db.Column(db.String(10), default='3.1')
    
    # Vulnerability classification
    category = db.Column(db.String(50), nullable=True, index=True)  # e.g., 'injection', 'auth'
    attack_vector = db.Column(db.Enum('network', 'adjacent', 'local', 'physical',
                                     name='attack_vectors'), nullable=True)
    attack_complexity = db.Column(db.Enum('low', 'high', name='attack_complexity'), nullable=True)
    
    # Impact assessment
    confidentiality_impact = db.Column(db.Enum('none', 'low', 'high', name='impact_levels'), nullable=True)
    integrity_impact = db.Column(db.Enum('none', 'low', 'high', name='impact_levels'), nullable=True)
    availability_impact = db.Column(db.Enum('none', 'low', 'high', name='impact_levels'), nullable=True)
    
    # Affected systems and versions
    affected_products = db.Column(db.Text, nullable=True)    # JSON array
    affected_versions = db.Column(db.Text, nullable=True)    # JSON array
    fixed_versions = db.Column(db.Text, nullable=True)       # JSON array
    
    # References and resources
    references = db.Column(db.Text, nullable=True)           # JSON array of URLs
    proof_of_concept = db.Column(db.Text, nullable=True)     # PoC code or steps
    remediation = db.Column(db.Text, nullable=True)          # Fix instructions
    workaround = db.Column(db.Text, nullable=True)           # Temporary workaround
    
    # Publication and disclosure
    published_date = db.Column(db.Date, nullable=True)
    disclosed_date = db.Column(db.Date, nullable=True)
    last_modified = db.Column(db.Date, nullable=True)
    
    # Status and metadata
    status = db.Column(db.Enum('draft', 'published', 'modified', 'rejected', 'withdrawn',
                              name='vuln_status'), default='draft')
    is_exploitable = db.Column(db.Boolean, default=False)
    exploit_available = db.Column(db.Boolean, default=False)
    
    # Internal tracking
    created_at = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=True)
    
    # Additional metadata
    tags = db.Column(db.Text, nullable=True)                 # JSON array of tags
    notes = db.Column(db.Text, nullable=True)
    
    # Relationships
    test_results = db.relationship('TestResult', backref='vulnerability', lazy='dynamic')
    
    def __init__(self, title, description, severity, **kwargs):
        """Initialize vulnerability."""
        self.title = title
        self.description = description
        self.severity = severity
        
        # Set additional fields
        for key, value in kwargs.items():
            if hasattr(self, key):
                setattr(self, key, value)
    
    @property
    def affected_products_list(self):
        """Get affected products as Python list."""
        if self.affected_products:
            try:
                return json.loads(self.affected_products)
            except (json.JSONDecodeError, TypeError):
                return []
        return []
    
    @affected_products_list.setter
    def affected_products_list(self, products):
        """Set affected products from Python list."""
        if isinstance(products, list):
            self.affected_products = json.dumps(products)
        else:
            self.affected_products = None
    
    @property
    def affected_versions_list(self):
        """Get affected versions as Python list."""
        if self.affected_versions:
            try:
                return json.loads(self.affected_versions)
            except (json.JSONDecodeError, TypeError):
                return []
        return []
    
    @affected_versions_list.setter
    def affected_versions_list(self, versions):
        """Set affected versions from Python list."""
        if isinstance(versions, list):
            self.affected_versions = json.dumps(versions)
        else:
            self.affected_versions = None
    
    @property
    def fixed_versions_list(self):
        """Get fixed versions as Python list."""
        if self.fixed_versions:
            try:
                return json.loads(self.fixed_versions)
            except (json.JSONDecodeError, TypeError):
                return []
        return []
    
    @fixed_versions_list.setter
    def fixed_versions_list(self, versions):
        """Set fixed versions from Python list."""
        if isinstance(versions, list):
            self.fixed_versions = json.dumps(versions)
        else:
            self.fixed_versions = None
    
    @property
    def references_list(self):
        """Get references as Python list."""
        if self.references:
            try:
                return json.loads(self.references)
            except (json.JSONDecodeError, TypeError):
                return []
        return []
    
    @references_list.setter
    def references_list(self, refs):
        """Set references from Python list."""
        if isinstance(refs, list):
            self.references = json.dumps(refs)
        else:
            self.references = None
    
    @property
    def tags_list(self):
        """Get tags as Python list."""
        if self.tags:
            try:
                return json.loads(self.tags)
            except (json.JSONDecodeError, TypeError):
                return []
        return []
    
    @tags_list.setter
    def tags_list(self, tags):
        """Set tags from Python list."""
        if isinstance(tags, list):
            self.tags = json.dumps(tags)
        else:
            self.tags = None
    
    def calculate_cvss_score(self, base_metrics):
        """Calculate CVSS score from base metrics."""
        # Simplified CVSS 3.1 calculation
        # In production, use a proper CVSS library
        
        attack_vector_scores = {'network': 0.85, 'adjacent': 0.62, 'local': 0.55, 'physical': 0.2}
        attack_complexity_scores = {'low': 0.77, 'high': 0.44}
        privileges_required_scores = {'none': 0.85, 'low': 0.62, 'high': 0.27}
        user_interaction_scores = {'none': 0.85, 'required': 0.62}
        impact_scores = {'high': 0.56, 'low': 0.22, 'none': 0.0}
        
        # Extract metrics
        av = attack_vector_scores.get(base_metrics.get('attack_vector', 'network'), 0.85)
        ac = attack_complexity_scores.get(base_metrics.get('attack_complexity', 'low'), 0.77)
        pr = privileges_required_scores.get(base_metrics.get('privileges_required', 'none'), 0.85)
        ui = user_interaction_scores.get(base_metrics.get('user_interaction', 'none'), 0.85)
        
        c = impact_scores.get(base_metrics.get('confidentiality_impact', 'none'), 0.0)
        i = impact_scores.get(base_metrics.get('integrity_impact', 'none'), 0.0)
        a = impact_scores.get(base_metrics.get('availability_impact', 'none'), 0.0)
        
        # Calculate ISS (Impact Sub Score)
        iss = 1 - ((1 - c) * (1 - i) * (1 - a))
        
        # Calculate exploitability
        exploitability = 8.22 * av * ac * pr * ui
        
        # Calculate base score
        if iss <= 0:
            base_score = 0.0
        else:
            impact = 6.42 * iss
            base_score = min(10.0, (impact + exploitability))
        
        self.cvss_score = round(base_score, 1)
        
        # Update severity based on CVSS score
        if self.cvss_score >= 9.0:
            self.severity = 'critical'
        elif self.cvss_score >= 7.0:
            self.severity = 'high'
        elif self.cvss_score >= 4.0:
            self.severity = 'medium'
        elif self.cvss_score > 0.0:
            self.severity = 'low'
        else:
            self.severity = 'info'
        
        db.session.commit()
    
    def is_applicable_to_device(self, device):
        """Check if vulnerability is applicable to a device."""
        if not self.affected_products_list:
            return True  # No product restrictions
        
        device_info = [
            device.manufacturer,
            device.model,
            device.device_type
        ]
        
        for product in self.affected_products_list:
            if any(product.lower() in str(info).lower() for info in device_info if info):
                return True
        
        return False
    
    def add_reference(self, url, description=None):
        """Add a reference URL."""
        current_refs = self.references_list
        ref_item = {'url': url}
        if description:
            ref_item['description'] = description
        
        current_refs.append(ref_item)
        self.references_list = current_refs
        db.session.commit()
    
    def add_tag(self, tag):
        """Add a tag to the vulnerability."""
        current_tags = self.tags_list
        if tag not in current_tags:
            current_tags.append(tag)
            self.tags_list = current_tags
            db.session.commit()
    
    def remove_tag(self, tag):
        """Remove a tag from the vulnerability."""
        current_tags = self.tags_list
        if tag in current_tags:
            current_tags.remove(tag)
            self.tags_list = current_tags
            db.session.commit()
    
    def to_dict(self, include_details=False):
        """Convert vulnerability to dictionary representation."""
        data = {
            'id': self.id,
            'cve_id': self.cve_id,
            'cwe_id': self.cwe_id,
            'external_id': self.external_id,
            'title': self.title,
            'description': self.description,
            'severity': self.severity,
            'cvss_score': self.cvss_score,
            'cvss_vector': self.cvss_vector,
            'cvss_version': self.cvss_version,
            'category': self.category,
            'attack_vector': self.attack_vector,
            'attack_complexity': self.attack_complexity,
            'status': self.status,
            'is_exploitable': self.is_exploitable,
            'exploit_available': self.exploit_available,
            'published_date': self.published_date.isoformat() if self.published_date else None,
            'disclosed_date': self.disclosed_date.isoformat() if self.disclosed_date else None,
            'last_modified': self.last_modified.isoformat() if self.last_modified else None,
            'created_at': self.created_at.isoformat() if self.created_at else None,
            'tags': self.tags_list
        }
        
        if include_details:
            data.update({
                'confidentiality_impact': self.confidentiality_impact,
                'integrity_impact': self.integrity_impact,
                'availability_impact': self.availability_impact,
                'affected_products': self.affected_products_list,
                'affected_versions': self.affected_versions_list,
                'fixed_versions': self.fixed_versions_list,
                'references': self.references_list,
                'proof_of_concept': self.proof_of_concept,
                'remediation': self.remediation,
                'workaround': self.workaround,
                'notes': self.notes
            })
        
        return data
    
    @classmethod
    def find_by_cve(cls, cve_id):
        """Find vulnerability by CVE ID."""
        return cls.query.filter_by(cve_id=cve_id).first()
    
    @classmethod
    def get_by_severity(cls, severity):
        """Get vulnerabilities by severity."""
        return cls.query.filter_by(severity=severity).all()
    
    @classmethod
    def get_critical_vulnerabilities(cls):
        """Get critical vulnerabilities."""
        return cls.query.filter_by(severity='critical').all()
    
    @classmethod
    def search_vulnerabilities(cls, query):
        """Search vulnerabilities by title, description, or CVE ID."""
        search_pattern = f'%{query}%'
        return cls.query.filter(
            db.or_(
                cls.title.like(search_pattern),
                cls.description.like(search_pattern),
                cls.cve_id.like(search_pattern)
            )
        ).all()
    
    @classmethod
    def get_exploitable_vulnerabilities(cls):
        """Get vulnerabilities with available exploits."""
        return cls.query.filter_by(exploit_available=True).all()
    
    @classmethod
    def get_recent_vulnerabilities(cls, days=30):
        """Get recently published vulnerabilities."""
        from datetime import date, timedelta
        cutoff_date = date.today() - timedelta(days=days)
        return cls.query.filter(cls.published_date >= cutoff_date).all()
    
    @classmethod
    def create_from_cve(cls, cve_data):
        """Create vulnerability from CVE data."""
        vulnerability = cls(
            cve_id=cve_data.get('cve_id'),
            title=cve_data.get('title'),
            description=cve_data.get('description'),
            severity=cve_data.get('severity', 'medium'),
            cvss_score=cve_data.get('cvss_score'),
            cvss_vector=cve_data.get('cvss_vector'),
            published_date=cve_data.get('published_date'),
            status='published'
        )
        
        # Set additional fields if available
        if 'affected_products' in cve_data:
            vulnerability.affected_products_list = cve_data['affected_products']
        
        if 'references' in cve_data:
            vulnerability.references_list = cve_data['references']
        
        db.session.add(vulnerability)
        db.session.commit()
        
        return vulnerability
    
    def __repr__(self):
        return f'<Vulnerability {self.cve_id or self.title} ({self.severity})>'
